# Real Lean 4 Trace Example
# Generated by: lake env lean --trace=Tactic.simp.rewrite Example.lean

[trace.Tactic.simp] goal: 
  n m : Nat
  ⊢ (n + m) + 0 = m + n

[trace.Tactic.simp.rewrite] Nat.add_zero: (n + m) + 0 ==> n + m
[trace.Tactic.simp] goal: 
  n m : Nat
  ⊢ n + m = m + n

[trace.Tactic.simp.rewrite] Nat.add_comm: n + m ==> m + n
[trace.Tactic.simp] goal simplified to: 
  n m : Nat
  ⊢ m + n = m + n

[trace.Tactic.simp.rewrite] eq_self_iff_true: m + n = m + n ==> True
[trace.Tactic.simp] goal simplified to: 
  n m : Nat
  ⊢ True

[trace.Tactic.simp.rewrite] trivial: True ==> True

# Example with failures
Example.lean:25:2: [trace.Tactic.simp] goal:
  l : List Nat
  h : l ≠ []
  ⊢ l.head? = some (l.head h)

Example.lean:25:2: [trace.Tactic.simp] trying simp lemma List.head?_cons
Example.lean:25:2: [trace.Tactic.simp] failed to apply simp lemma List.head?_cons
Example.lean:25:2: [trace.Tactic.simp] trying simp lemma List.head_cons
Example.lean:25:2: [trace.Tactic.simp] failed to apply simp lemma List.head_cons

# Multiple applications in sequence
[trace.Tactic.simp.rewrite] List.map_cons: map f (x :: xs) ==> f x :: map f xs
[trace.Tactic.simp.rewrite] List.map_nil: map f [] ==> []
[trace.Tactic.simp.rewrite] List.append_nil: (f x :: map f xs) ++ [] ==> f x :: map f xs

# Complex rewrite with instantiation
[trace.Meta.Tactic.simp.rewrite] List.length_append: 
  length (l₁ ++ l₂) ==> length l₁ + length l₂
[trace.Meta.Tactic.simp.rewrite] List.length_cons: 
  length (x :: xs) ==> 1 + length xs
[trace.Meta.Tactic.simp.rewrite] Nat.succ_eq_add_one: 
  Nat.succ n ==> n + 1